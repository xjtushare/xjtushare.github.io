<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-22T07:29:20.347Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Pu Cao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>01. 两数之和</title>
    <link href="http://example.com/2021/04/22/lc-01-twoSum/"/>
    <id>http://example.com/2021/04/22/lc-01-twoSum/</id>
    <published>2021-04-22T07:09:21.000Z</published>
    <updated>2021-04-22T07:29:20.347Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、题目描述：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 两数之和</span><br><span class="line">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</span><br><span class="line"></span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span><br><span class="line"></span><br><span class="line">你可以按任意顺序返回答案。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>二、我的思路：</strong></p><ol><li>使用哈希表（key,value）分别记录数组里面的元素和对应的下标，</li><li>如果key = target-当前的数nums[i],说明之前遍历过的数字key + 当前的数 等于target，</li><li>那么返回之前遍历过的数字key对应的下标 和当前遍历到的元素nums[i]的下标i。</li><li>如果当前遍历到的数字nums[i],用target - nums[i]得到的数不在map里面，说明当前还没有找到一个数和当前数相加等于target；那么就把当前数字nums[i]和对应的下标i加入到map中。</li><li>如果遍历完了整个数组都没有找到符合条件的，则return new int[]{-1,-1};</li></ol><p><strong>三、AC 代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            int temp &#x3D; target - nums[i];</span><br><span class="line">            if(map.containsKey(temp))&#123;</span><br><span class="line">                return new int[]&#123;map.get(temp),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        return new int[]&#123;-1,-1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>四、总结：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array | hash-table </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
    <category term="leetcode.hash-table" scheme="http://example.com/tags/leetcode-hash-table/"/>
    
    <category term="leetcode.array" scheme="http://example.com/tags/leetcode-array/"/>
    
  </entry>
  
  <entry>
    <title>hadoop01. hadoop概念</title>
    <link href="http://example.com/2021/04/05/dsj-hadoop01/"/>
    <id>http://example.com/2021/04/05/dsj-hadoop01/</id>
    <published>2021-04-04T16:50:48.000Z</published>
    <updated>2021-04-04T17:51:12.684Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、What is hadoop?</strong><br><strong>1、概念</strong></p><p>一个允许用简单的编程模型在计算机集群上对大型数据集进行分布式处理的基础框架。<br>低成本、高可靠、高扩展、高有效、高容错等特性让 hadoop 成为最流行的大数据分析系统<br>功能：提供本地计算和存储功能<br>Apache™ Hadoop® project develops open-source software for reliable, scalable, distributed computing.<br>The Apache Hadoop software library is a framework that allows for the distributed processing of large data sets across clusters of computers using simple programming models. It is designed to scale up from single servers to thousands of machines, each offering local computation and storage</p><p>来源：  <a href="http://hadoop.apache.org/">http://hadoop.apache.org</a></p><p><strong>2、hadoop优势</strong></p><p>1、高可靠：<br>hadoop底层维护的多副本机制，（默认3个）。某个计算元素或者存储挂了，不会导致数据丢失。<br>2、高扩展：<br> 集群见分配任务，节点扩展很方便，（动态扩展）<br>3、高效性：<br>MapReduce思想，hadoop并行工作，任务处理快。（多个节点共同处理）</p><p>4、高容错：<br> 自动将失败的任务重新分配：<br> 比如某一个节点挂了，则hadoop会自动的把这个节点的任务分配到其他节点，并正常运行（涉及到调度机制）</p><p><strong>3、hadoop1.x 2.x 3.x区别</strong></p><p>1、hadoop1.x </p><ul><li>HDFS(数据存储)</li><li>MapReduce(计算+资源调度(CPU,内存，磁盘))</li><li>Common（辅助工具）</li></ul><p>2、hadoop2.x （解藕，MapReduce）</p><ul><li>HDFS(数据存储)</li><li>MapReduce(计算)</li><li>Common（辅助工具）</li><li>**Yarm(资源调度(CPU,内存，磁盘)) **</li></ul><p>3、hadoop3.x </p><blockquote><p><a href="http://hadoop.apache.org/docs/r3.0.1/">http://hadoop.apache.org/docs/r3.0.1/</a></p></blockquote><ul><li>最低Java版本要求从Java7变为Java8</li><li>HDFS支持纠删码，将原本3倍的存储消耗降低到1.4倍。</li></ul><p>Hadoop1.x,hadoop的MapReduce同时处理业务逻辑运算和资源调度，耦合性高。<br>Hadoop2.x,hadoop增加了Yarn，Yarn单独负责资源调度。MapReduce只负责运算。</p><p><strong>4、Hadoop 生态圈</strong></p><p><img src="/2021/04/05/dsj-hadoop01/1.jpeg"></p><p> Hadoop 的生态系统，主要由 HDFS、MapReduce， HBase， Zookeeper， Pig、 Hive 等核心组件构成，另外还包括 Sqoop、Flume 等框架，用来与其他企业系统融合</p><p> Hadoop 生态圈包括以下主要组件。<br>1）HDFS<br>一个提供高可用的获取应用数据的分布式文件系统<br>2）MapReduce<br>一个并行处理大数据集的编程模型<br>3）HBase<br>一个可扩展的分布式数据库，支持大表的结构化数据存储。是一个建立在 HDFS 之上的，面向列的 NoSQL 数据库，用于快速读/写大量数据。</p><p>4）Hive<br>一个建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具；可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。</p><p>Hive 定义了简单的类 SQL 查询语言，称为 HQL，它允许不熟悉 MapReduce 的开发人员也能编写数据查询语句，然后这些语句被翻译为 Hadoop 上面的 MapReduce 任务</p><p>5）Zookeeper<br>—个应用于分布式应用的高性能的协调服务。它是一个为分布式应用提供一致性服务的软件，提供的功能包括配置维护、域名服务、分布式同步、组服务等。<br>6）Flume<br>提供了分布式、可靠、高效的服务，用于收集、汇总大数据，并将单台计算机的大量数据转移到 HDFS。它基于一个简单而灵活的架构，并提供了数据流的流。它利用简单的可扩展的数据模型，将企业中多台计算机上的数据转移到 Hadoop</p><p><strong>二、hdfs主要解决的问题：</strong><br>文件系统是操作系统提供的磁盘空间管理服务，该服务只需要用户指定文件的存储位置及文件读取路径，而不需要用户了解文件在磁盘上是如何存放的。</p><p>当文件所需空间大于本机磁盘空间时，通常：</p><ul><li><p>加磁盘，但是加到一定程度就受限制了。</p></li><li><p>加机器，即用远程共享目录的方式提供网络化的存储，它可以把不同文件放入不同的机器中，而且空间不足时可继续加机器，突破了存储空间的限制。</p></li><li><p><em>传统的分布式文件系统：</em>*<br>1）各个存储结点的负载不均衡，单机负载可能极高（经常读取某个机器上的某个热门文件）<br>2）数据可靠性低（机器挂了，文件就不能访问）<br>3）文件管理困难（文件的存储位置，机器的空间维护调整）</p></li></ul><p><strong>三、设计设计思想：</strong></p><p>HDFS 的设计理念是为了满足特定的大数据应用场景，提供对应用程序数据的高吞吐量访问，并且适用于具有大数据集的应用程序，可以运行在普通机器上，以流式数据方式存储文件，一次写入、多次查询。</p><blockquote><p><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html">https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html</a><br>1、高容错性<br> HDFS 将数据自动保存多个副本，副本丢失后，自动恢复，从而实现数据的高容错性<br>2、适合批处理<br>HDFS 适合一次写入、多次查询（读取）的情况。在数据集生成后，需要长时间在此数据集上进行各种分析。每次分析都将涉及该数据集的大部分数据甚至全部数据，因此读取整个数据集的时间延迟比读取第一条记录的时间延迟更重要。<br>3、适合存储大文件<br>这里说的大文件包含两种意思：一是值文件大小超过 100MB 及达到 GB 甚至 TB、PB 级的文件;二是百万规模以上的文件数量。</p></blockquote><p><strong>四、架构</strong><br><strong>1、HDFS(The Hadoop Distributed File System)架构（负责存储）</strong></p><ul><li>NameNode         存储文件元数据(文件名、目录，文件属性、文件块列表以及块所在的DataNode)</li><li>DataNode       存储文件的块数据</li><li>Secondary NameNode    监控HDFS状态的后台程序，每隔一段时间，获取HDFS元数据的快照</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、What is hadoop?&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;1、概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个允许用简单的编程模型在计算机集群上对大型数据集进行分布式处理的基础框架。&lt;br&gt;低成本、高可靠、高扩展、高有效、高容错等特性让 hado</summary>
      
    
    
    
    
    <category term="bigdata.hadoop" scheme="http://example.com/tags/bigdata-hadoop/"/>
    
  </entry>
  
  <entry>
    <title>w02. 分析一门技术 可这样</title>
    <link href="http://example.com/2021/04/02/%E5%88%86%E6%9E%90%E4%B8%80%E9%97%A8%E6%8A%80%E6%9C%AF-%E5%8F%AF%E8%BF%99%E6%A0%B7/"/>
    <id>http://example.com/2021/04/02/%E5%88%86%E6%9E%90%E4%B8%80%E9%97%A8%E6%8A%80%E6%9C%AF-%E5%8F%AF%E8%BF%99%E6%A0%B7/</id>
    <published>2021-04-02T03:04:09.000Z</published>
    <updated>2021-04-02T03:09:31.842Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、What is ?</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">......</span><br></pre></td></tr></table></figure><p><strong>二、Why do we need it ?：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">......</span><br></pre></td></tr></table></figure><p><strong>三、背后的设计考虑以及设计思想：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">......</span><br></pre></td></tr></table></figure><p><strong>四、架构以及技术细节</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">......</span><br></pre></td></tr></table></figure><p><strong>五、适合的应用场景</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">......</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、What is ?&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;</summary>
      
    
    
    
    
    <category term="way" scheme="http://example.com/tags/way/"/>
    
  </entry>
  
  <entry>
    <title>w01. 题目可这样解析</title>
    <link href="http://example.com/2021/04/02/00-%E9%A2%98%E7%9B%AE%E5%8F%AF%E8%BF%99%E6%A0%B7%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/04/02/00-%E9%A2%98%E7%9B%AE%E5%8F%AF%E8%BF%99%E6%A0%B7%E8%A7%A3%E6%9E%90/</id>
    <published>2021-04-02T01:18:58.000Z</published>
    <updated>2021-04-02T03:08:21.592Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、题目描述：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.......</span><br></pre></td></tr></table></figure><p><strong>二、思路分析：</strong></p><ul><li>这道题考察了什么思想？你的思路是什么？</li><li>做题的时候是不是一次通过的，遇到了什么问题，需要注意什么细节？</li><li>有几种解法，哪种解法时间复杂度最低，哪种解法空间复杂度最低，最优解法是什么？其他人的题解是什么，谁的效率更好一些？用不同语言实现的话，哪个语言速度最快？</li></ul><p><strong>三、AC 代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxxx</span><br></pre></td></tr></table></figure><p><strong>四、总结：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">更多的思考、分析、总结</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td</summary>
      
    
    
    
    
    <category term="way" scheme="http://example.com/tags/way/"/>
    
  </entry>
  
  <entry>
    <title>03. 无重复字符的最长子串</title>
    <link href="http://example.com/2021/04/01/03-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://example.com/2021/04/01/03-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</id>
    <published>2021-04-01T14:37:18.000Z</published>
    <updated>2021-04-02T03:10:30.862Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、题目描述：</strong><br> 无重复字符的最长子串<br> 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p> 示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p> 示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p> 示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;= s.length &lt;= 5 * 104</li><li>s 由英文字母、数字、符号和空格组成</li></ul><p><strong>二、思路分析：</strong></p><p>这道题考察：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash-table | two-pointers | string | sliding-window</span><br></pre></td></tr></table></figure><p>我的思路：<br> 重复性的处理： 借助HashSet</p><ul><li>1、借助 HashSet，定义一个左起点left，</li><li>2、遍历字符串的每一个字符串，如果set里面包含该字符，则删除前面已经加入的这个字符，即下标为left的字符，然后left向右移动到下一个位置，继续考察</li><li>3、如果遍历到的当前字符不再set里，则把当前字符加入到set中，最终无重复字符组成的字串的最长长度ans = Math.max(ans,index-left+1)</li></ul><p><strong>三、AC 代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @lc code&#x3D;start</span><br><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F;corner case</span><br><span class="line">        if(s&#x3D;&#x3D;null || s.length() &#x3D;&#x3D;0) return 0;</span><br><span class="line">        int ans &#x3D; 0;</span><br><span class="line">        int left &#x3D; 0;</span><br><span class="line">        Set&lt;Character&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        for(int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;left &lt;&#x3D; i 特别注意</span><br><span class="line">            while (left &lt;&#x3D; i &amp;&amp; set.contains(s.charAt(i))) &#123;</span><br><span class="line">                set.remove(s.charAt(left));</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(s.charAt(i));</span><br><span class="line">            ans &#x3D; Math.max(ans, i-left+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>四、总结：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash-table | two-pointers | string | sliding-window</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、题目描述：&lt;/strong&gt;&lt;br&gt; 无重复字符的最长子串&lt;br&gt; 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
&lt;p&gt; 示例 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr</summary>
      
    
    
    
    
    <category term="leetcode.String" scheme="http://example.com/tags/leetcode-String/"/>
    
    <category term="leetcode.hash-table" scheme="http://example.com/tags/leetcode-hash-table/"/>
    
    <category term="leetcode.two-pointers" scheme="http://example.com/tags/leetcode-two-pointers/"/>
    
    <category term="leetcode.sliding-window" scheme="http://example.com/tags/leetcode-sliding-window/"/>
    
  </entry>
  
  <entry>
    <title>20. 有效的括号</title>
    <link href="http://example.com/2021/03/30/20-Valid-Parentheses/"/>
    <id>http://example.com/2021/03/30/20-Valid-Parentheses/</id>
    <published>2021-03-30T02:07:20.000Z</published>
    <updated>2021-04-02T03:10:30.856Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、题目描述：</strong><br>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。<br>示例 1：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;([)]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>示例 5：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p> </p><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 104</li><li>s 仅由括号 ‘()[]{}’ 组成</li></ul><p><strong>二、思路分析：</strong></p><p> <strong>1.暴力</strong><br> ：不断replace匹配的括号</p><ul><li>情况： a. ()[]{}</li><li>b. (([]))  找到匹配的替换成空</li><li>o(n平方)</li></ul><p> <strong>2.我的思路：使用栈</strong></p><ul><li>如果是左括号，就压入右括号到栈里面去； loop</li><li>如果是右括号，就和栈顶元素进行比较，看是否匹配，如果匹配(==)，就栈顶元素出栈，栈中元素减少一个，同时字符串的index跳到下一个字符，消除这对括号，不然就不合法。</li><li>最后要判断下栈里面的所有元素都清空了，并且每一次扫描的字符不会和栈顶元素匹配不上</li><li><em>三、AC 代码：</em>*</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class isValid &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F;        遍历一遍整个字符串，遇到左括号，把相对应的右括号压入栈，</span><br><span class="line">&#x2F;&#x2F;        这样弹栈pop的时候，弹出的值和当前字符串中扫描到的值是否一样</span><br><span class="line">        for (char c : s.toCharArray()) &#123;</span><br><span class="line">            if (c &#x3D;&#x3D; &#39;(&#39;) &#123;</span><br><span class="line">                stack.push(&#39;)&#39;);</span><br><span class="line">            &#125; else if (c &#x3D;&#x3D; &#39;&#123;&#39;) &#123;</span><br><span class="line">                stack.push(&#39;&#125;&#39;);</span><br><span class="line">            &#125; else if (c &#x3D;&#x3D; &#39;[&#39;) &#123;</span><br><span class="line">                stack.push(&#39;]&#39;);</span><br><span class="line">            &#125; else if (stack.isEmpty() || stack.pop() !&#x3D; c) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>四、总结：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string | stack</span><br></pre></td></tr></table></figure><ul><li>栈解决的问题：</li><li>最近相关性</li><li>先来后到，先进后出问题。</li><li>比较复杂的算法最后都归结到找最近的重复性</li><li>因为只能写 if else; for loop 和recursion</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、题目描述：&lt;/strong&gt;&lt;br&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左括号必须用相同类型的右括号闭合。&lt;/li&gt;
&lt;li&gt;左</summary>
      
    
    
    
    
    <category term="leetcode.String" scheme="http://example.com/tags/leetcode-String/"/>
    
    <category term="leetcode.stack" scheme="http://example.com/tags/leetcode-stack/"/>
    
  </entry>
  
  <entry>
    <title>200. numIslands</title>
    <link href="http://example.com/2021/03/30/200-numIslands/"/>
    <id>http://example.com/2021/03/30/200-numIslands/</id>
    <published>2021-03-30T01:57:44.000Z</published>
    <updated>2021-04-02T03:10:12.716Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、题目描述：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。</span><br><span class="line"></span><br><span class="line">岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</span><br><span class="line"></span><br><span class="line">此外，你可以假设该网格的四条边均被水包围。</span><br></pre></td></tr></table></figure><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>m == grid.length</li><li>n == grid[i].length</li><li>1 &lt;= m, n &lt;= 300</li><li>grid[i][j] 的值为 ‘0’ 或 ‘1’</li></ul><p><strong>二、思路分析：</strong></p><p>这道题考察：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">depth-first-search | breadth-first-search | union-find</span><br></pre></td></tr></table></figure><p>我的思路：深度搜索DFS</p><ul><li>DFS：从一个点开始往下走，走到尽可能远，远到不能走下去的时候才返回上一级</li><li>一般用Recursion迭代，其中最关键的就是终止条件，</li></ul><p><strong>解析：</strong><br><img src="/2021/03/30/200-numIslands/p1.png" alt="-"></p><p><strong>point 1</strong><br>每次都是遇到‘1‘之后，开始DFS算法，也就是向四个方向延伸，直到不能继续延伸，就找到了一个岛</p><p><strong>point 2</strong><br>那么如何才能再二维数组中找到‘1’的点呢？ –》 two for loop<br>DFS，一般使用迭代，终止条件：<br>1、走到不是1的时候停止<br>2、走到了数组的边界就停止</p><p><strong>point 3</strong><br>如何避免重复？<br>1、避免重复遍历已经遍历过的元素，比如1； –》标记法来避免（遍历过就把1标记为#）<br>2、避免重复遍历已经遍历过的岛</p><p> <img src="/2021/03/30/200-numIslands/p2.png" alt="-"></p><p><strong>三、AC 代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @lc code&#x3D;start</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int numIslands(char[][] arr) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; row</span><br><span class="line">        for(int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;    col</span><br><span class="line">            for(int j &#x3D; 0; j&lt; arr[0].length; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果当前元素arr[i][j]&#x3D;&#x3D;“1”，就进行DFS深搜</span><br><span class="line">                if(arr[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">                    dfs(arr, i, j);</span><br><span class="line">                    &#x2F;&#x2F;dfs深搜完之后，就说明产生了一个岛，res++，记录岛的num</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 深搜DFS</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void dfs(char[][] arr, int i, int j) &#123;</span><br><span class="line">        &#x2F;&#x2F;corner case  | arr[i][j] !&#x3D;&#39;1&#39; </span><br><span class="line">        if(i &lt; 0 || i &gt;&#x3D; arr.length || j &lt; 0 || j &gt;&#x3D; arr[0].length || arr[i][j] !&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 当前点标记为#</span><br><span class="line">        arr[i][j] &#x3D; &#39;#&#39;;</span><br><span class="line">        &#x2F;&#x2F;上下左右进行DFS</span><br><span class="line">        dfs(arr, i+1, j);</span><br><span class="line">        dfs(arr, i-1, j);</span><br><span class="line">        dfs(arr, i, j+1);</span><br><span class="line">        dfs(arr, i, j-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;end</span><br><span class="line"></span><br><span class="line">****</span><br></pre></td></tr></table></figure><p><img src="/2021/03/30/200-numIslands/p3.png" alt="-"></p><p><strong>四、总结：</strong></p><ul><li>dfs</li><li>bfs</li><li>union-find</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
    <category term="leetcode.depth-first-search" scheme="http://example.com/tags/leetcode-depth-first-search/"/>
    
    <category term="leetcode.breadth-first-search" scheme="http://example.com/tags/leetcode-breadth-first-search/"/>
    
    <category term="leetcode.union-find" scheme="http://example.com/tags/leetcode-union-find/"/>
    
  </entry>
  
  <entry>
    <title>98. 验证二叉搜索树</title>
    <link href="http://example.com/2021/03/29/98-ValidateBinarySearchTree/"/>
    <id>http://example.com/2021/03/29/98-ValidateBinarySearchTree/</id>
    <published>2021-03-29T08:29:16.000Z</published>
    <updated>2021-04-02T02:08:06.952Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、题目描述：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，判断其是否是一个有效的二叉搜索树。</span><br><span class="line"></span><br><span class="line">假设一个二叉搜索树具有如下特征：</span><br><span class="line"></span><br><span class="line">节点的左子树只包含小于当前节点的数。</span><br><span class="line">节点的右子树只包含大于当前节点的数。</span><br><span class="line">所有左子树和右子树自身必须也是二叉搜索树。</span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;validate-binary-search-tree</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p><strong>二、思路分析：</strong></p><ol><li><p>方法2:inorder, =&gt; array 升序，不需要保留所有节点，只需要保留前继节点即可</p></li><li><p>递归： Recursion  </p><pre><code>  valid(root,min,max)&#123;&#125;  max &lt;-  valid(node.left)  min &lt;- valid(node.right)  左边 max&lt;root, 并且 右边min &gt;root 说明是二叉搜素树  同理，递归  </code></pre></li></ol><p>我的思路：</p><ul><li>定义一个全局最大值，最小值，如果根节点的值大于全局最大值，或者小于全局最小值，则不满足二叉搜索树的性质。</li><li>然后对左子树和右子树进行考察，如果是二叉搜索树，那么左子树的最大值必须小于根节点，即根节点为左子树的上界；并且右子树的最小值必须大于根节点的值，所以更新右子树的最小值为root.val</li></ul><p><strong>三、AC 代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val &#x3D; val;</span><br><span class="line"> *         this.left &#x3D; left;</span><br><span class="line"> *         this.right &#x3D; right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        &#x2F;&#x2F;定义全局的最大值，最小值</span><br><span class="line">        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isValidBST(TreeNode root, long minVal, long maxVal) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) return true;</span><br><span class="line">        &#x2F;&#x2F;所有的节点的上下界，max，min</span><br><span class="line">        if (root.val &gt;&#x3D; maxVal || root.val &lt;&#x3D; minVal) return false;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 遍历左子树</span><br><span class="line">         * 左子树不能大于root，所以root.val变成了上界</span><br><span class="line">         * 同理：遍历右子树</span><br><span class="line">         * 右子树所有节点都比root.val大，所以右子树变为了下界</span><br><span class="line">         *&#x2F;</span><br><span class="line">        return isValidBST(root.left, minVal, root.val) &amp;&amp; isValidBST(root.right, root.val, maxVal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>四、总结：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree | depth-first-search</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
    <category term="leetcode.depth-first-search" scheme="http://example.com/tags/leetcode-depth-first-search/"/>
    
    <category term="leetcode.tree" scheme="http://example.com/tags/leetcode-tree/"/>
    
  </entry>
  
  <entry>
    <title>611. 有效三角形的个数</title>
    <link href="http://example.com/2021/03/29/611-triangleNumber/"/>
    <id>http://example.com/2021/03/29/611-triangleNumber/</id>
    <published>2021-03-29T02:27:23.000Z</published>
    <updated>2021-04-02T03:10:11.425Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、题目描述：</strong></p><p>给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,3,4]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">有效的组合是: </span><br><span class="line">2,3,4 (使用第一个 2)</span><br><span class="line">2,3,4 (使用第二个 2)</span><br><span class="line">2,2,3</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>数组长度不超过1000。</li><li>数组里整数的范围为 [0, 1000]。</li></ul><p><strong>二、思路分析：</strong></p><ul><li><p>组成三角形条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任意的两边之和大于第三边</span><br></pre></td></tr></table></figure></li><li><p><em>我的思路</em>*</p></li><li><p>对数组排序，比如[2,3,4,5,6]，一开始第三边为数组最后一个数 a= nums.length-1;另外两个指针，left=0；right=nums.length-2;<br>nums[left]=2; nums[right]=5</p></li><li><p>考察l到r的数是否满足两边之和大于第三边；<br>如果2+5&gt;6,那么，从2开始到5之间的所有数加上5都是大于6的，也就是从下标0开始到下标2之间的数加上5都大于6，即<br>2+5&gt;6<br>3+5&gt;6<br>4+5&gt;6</p></li><li><p>所以，当l=0，r=nums.length-2时候，能够组成的三角形个数为count += r-l即3-0=3，共有3个。</p></li><li><p>然后当第三边为a=nums.length-2的时候，继续考察… </p></li></ul><p><strong>三、AC 代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int triangleNumber(int[] nums) &#123;</span><br><span class="line">        if(nums.length&lt;3) return 0;</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        Arrays.sort(nums); &#x2F;&#x2F;like [2,3,4,5,6]</span><br><span class="line">        for(int a&#x3D;nums.length-1;a&gt;&#x3D;2;a-- )&#123;</span><br><span class="line">            int l&#x3D;0,r&#x3D;a-1;</span><br><span class="line">            while(l&lt;r)&#123;</span><br><span class="line">                if(nums[l]+nums[r]&gt;nums[a])&#123;</span><br><span class="line">                    &#x2F;&#x2F;nums[l]+nums[r]满足&gt;nums[a]，那么从l到r-1之间的所有元素加nums[r]都大于nums[a]</span><br><span class="line">                    count +&#x3D; r-l;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>四、总结：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td </summary>
      
    
    
    
    
    <category term="leetcode.array" scheme="http://example.com/tags/leetcode-array/"/>
    
  </entry>
  
  <entry>
    <title>d01. Array 数组</title>
    <link href="http://example.com/2021/03/25/array/"/>
    <id>http://example.com/2021/03/25/array/</id>
    <published>2021-03-25T06:02:25.000Z</published>
    <updated>2021-04-02T03:23:38.728Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、What is array?</strong></p><ul><li><p>A variable is a memory location that can store a value. It can be thought of as a box in which values are stored. The value held in the box can change, or vary. But each variable can only hold one item of data.</p></li><li><p>An array is a series of memory locations – or ‘boxes’ – each of which holds a single item of data, but with each box sharing the same name. All data in an array must be of the same data type.</p></li></ul><p><strong>二、Why do we need array ?</strong></p><p>For example, imagine that a score table in a game needs to record ten scores. One way to do this is to have a variable for each score:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">score_0</span><br><span class="line">score_1</span><br><span class="line">score_2</span><br><span class="line">score_3</span><br><span class="line">score_4</span><br><span class="line">score_5</span><br><span class="line">score_6</span><br><span class="line">score_7</span><br><span class="line">score_8</span><br><span class="line">score_9</span><br></pre></td></tr></table></figure><p>This would work, but there is a better way. It is much simpler to keep all the related data under one name. We do this by using an array.</p><p>Instead of having ten variables, each holding a score, there could be one array that holds all the related data:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">score(9)</span><br></pre></td></tr></table></figure><p>Each ‘box’ in an array is referred to as an element.<br>It helps to think of an array as a row of cells, like the ones found in a table. Each cell represents an element:</p><p><img src="/2021/03/25/array/p1.png" alt="-"></p><ul><li><p>The individual values, or array elements, are numbered 0 to 9 because computers start counting at 0.</p></li><li><p>Any facility that holds more than one item of data is known as a data structure. Therefore, an array is a data structure.</p></li></ul><p><strong>三、技术细节</strong></p><p><strong>1. 写法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int arr[10];</span><br></pre></td></tr></table></figure><p><strong>2. 特性</strong><br>内存中开辟连续地址，通过内存管理器直接访问，O(1)</p><p><strong>3. 缺点</strong><br><img src="/2021/03/25/array/16166524808045.jpg" alt="-w629"></p><p><strong>4. 源代码解析 –ArrayList</strong></p><ol><li>在数据的末尾添加一个元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * Appends the specified element to the end of this list.</span><br><span class="line">   *</span><br><span class="line">   * @param e element to be appended to this list</span><br><span class="line">   * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line">   *&#x2F;</span><br><span class="line">   &#x2F;&#x2F;1.把一个元素加入到数组最后</span><br><span class="line">  public boolean add(E e) &#123;</span><br><span class="line">  &#x2F;&#x2F;2.首先保证size有size+1这么大</span><br><span class="line">      ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">      &#x2F;&#x2F;3.然后在数据的末尾，添加上e这个元素，同时把size++，最后return true，表示添加成功</span><br><span class="line">      elementData[size++] &#x3D; e;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li> 在index位置添加一个元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line">     * Inserts the specified element at the specified position in this</span><br><span class="line">     * list. Shifts the element currently at that position (if any) and</span><br><span class="line">     * any subsequent elements to the right (adds one to their indices).</span><br><span class="line">     *</span><br><span class="line">     * @param index index at which the specified element is to be inserted</span><br><span class="line">     * @param element element to be inserted</span><br><span class="line">     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void add(int index, E element) &#123;</span><br><span class="line">    &#x2F;&#x2F;1、检查上下界</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">&#x2F;&#x2F;2、确保容量</span><br><span class="line">        ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">       &#x2F;&#x2F;3. 拷贝： 把原来地址的起点位置，拷贝到目标地址的起点位置，source位置移动到index+1位置去</span><br><span class="line">       &#x2F;&#x2F;size-index即这个数组后半部分要挪到的部分， </span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                         size - index);</span><br><span class="line">        &#x2F;&#x2F;填入值</span><br><span class="line">        elementData[index] &#x3D; element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>即把EFG从3移动到了4的位置，如下图：</p><p><img src="/2021/03/25/array/16166535205113.jpg" alt="-w446"></p><p><strong>5、数组容量的扩容机制</strong><br>如果数组的容量不够，直接new一个新的数组，新的数组的长度为当前数组的长度+当前数组长度的一半，即老数组的1.5倍。<br>然后把老数组的值拷贝到新数组中去，返回新的数组即可</p><p>因此如果对ArrayList进行大量修改操作，涉及到大量的array copy，所以时间复杂度是很低的。</p><p>为了弥补这个缺点，链表完美了解决了大量修改操作带来的时间复杂度开销问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">         grow(minCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F;新数组容量为老数组的1.5</span><br><span class="line"> int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line"> &#x2F;&#x2F;把所有元素拷贝到新数组中去</span><br><span class="line">elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">     </span><br></pre></td></tr></table></figure><p><strong>附：详细代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">    * Increases the capacity of this &lt;tt&gt;ArrayList&lt;&#x2F;tt&gt; instance, if</span><br><span class="line">    * necessary, to ensure that it can hold at least the number of elements</span><br><span class="line">    * specified by the minimum capacity argument.</span><br><span class="line">    *</span><br><span class="line">    * @param   minCapacity   the desired minimum capacity</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public void ensureCapacity(int minCapacity) &#123;</span><br><span class="line">       int minExpand &#x3D; (elementData !&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">           &#x2F;&#x2F; any size if not default element table</span><br><span class="line">           ? 0</span><br><span class="line">           &#x2F;&#x2F; larger than default for default empty table. It&#39;s already</span><br><span class="line">           &#x2F;&#x2F; supposed to be at default size.</span><br><span class="line">           : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">       if (minCapacity &gt; minExpand) &#123;</span><br><span class="line">           ensureExplicitCapacity(minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">       if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">       return minCapacity;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">       ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">       if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * Increases the capacity to ensure that it can hold at least the</span><br><span class="line">  * number of elements specified by the minimum capacity argument.</span><br><span class="line">  *</span><br><span class="line">  * @param minCapacity the desired minimum capacity</span><br><span class="line">  *&#x2F;</span><br><span class="line"> private void grow(int minCapacity) &#123;</span><br><span class="line">     &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">     int oldCapacity &#x3D; elementData.length;</span><br><span class="line">     &#x2F;&#x2F;新数组容量</span><br><span class="line">     int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">     if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">         newCapacity &#x3D; minCapacity;</span><br><span class="line">     if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">         newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">     &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:</span><br><span class="line">     &#x2F;&#x2F;把所有元素拷贝到新数组中去</span><br><span class="line">     elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、What is array?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A variable is a memory location that can store a value. It can be thought of as a box i</summary>
      
    
    
    
    
    <category term="Data Structures" scheme="http://example.com/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>14. longest-common-prefix</title>
    <link href="http://example.com/2021/03/25/14_longest-common-prefix/"/>
    <id>http://example.com/2021/03/25/14_longest-common-prefix/</id>
    <published>2021-03-25T02:30:28.000Z</published>
    <updated>2021-04-02T03:10:30.852Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、题目描述：</strong></p><ol start="14"><li>最长公共前缀<br>编写一个函数来查找字符串数组中的最长公共前缀。</li></ol><p>如果不存在公共前缀，返回空字符串 “”。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：strs &#x3D; [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出：&quot;fl&quot;</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：strs &#x3D; [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;= strs.length &lt;= 200</li><li>0 &lt;= strs[i].length &lt;= 200</li><li>strs[i] 仅由小写英文字母组成</li></ul><p><strong>二、思路分析：</strong></p><ul><li><p>这道题考察的思想是：数组元素比对，可以水平比对，也可以竖直比对；也可以按字符串的字典序来排序对比</p></li><li><p>做题的时候不是一次性通过的，特别注意往往水平扫描是不建议的</p></li><li><p><strong>建议的做法：1、竖直扫描比对；2:对数组排序，按照字典序列来比对</strong></p></li><li><p>需要考虑的情况：Clarification(means Possible situation)：</p><pre><code>   1、 String arr null or empty?   2、 String null or empty?   3、 lower-case Englist letters? 如果有Upper-case，是否需要ignore case</code></pre></li><li><p>方法 1:Horizontal Scan （水平比较）<br>   arr for loop 每两个字符串相比较，直到比较到最后一个字符串，就找到了共同前缀</p></li></ul><p><img src="/2021/03/25/14_longest-common-prefix/16163813815934.jpg" alt="-w899"></p><ul><li>不足：前面对owe的比较都是多余的，因为后面的单词中没有的，最终都被删除了。</li></ul><ul><li>方法 2: vertically Scan (竖直扫描)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">每个单词的第一个字符 f；</span><br><span class="line">每个单词的第二个字符 l；</span><br><span class="line">每个单词的第三个字符 0，i；</span><br><span class="line">&#x3D;》共同前缀，fl</span><br></pre></td></tr></table></figure><p>   <img src="/2021/03/25/14_longest-common-prefix/16163818004512.jpg" alt="-w887"></p><p><strong>key Points of Vertical Scan</strong></p><p><img src="/2021/03/25/14_longest-common-prefix/16163837594595.jpg" alt="-w881"></p><p>1、拿到第一个字符串的第一个字符和后面的字符串比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c &#x3D; str[0].charAt(i);</span><br></pre></td></tr></table></figure><p>2、Boundary check 数组越界检查**<br>如果i已经达到了当前这个string的长度，就说明可以停止继续scan了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(i&#x3D;&#x3D;str[j].length())&#123;&#125;</span><br></pre></td></tr></table></figure><p>3、stop position is not part of the prefix</p><p>4、substring(start,end)<br>是不包含end位置(end is excluded in the substring)，所以可以用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Strs[0].substring(0,i);</span><br></pre></td></tr></table></figure><p>5、Finish Scan<br>    已经走完的即 最长的共同前缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return strs[0]</span><br></pre></td></tr></table></figure><p><strong>三、AC代码：</strong></p><p><strong>解法1 竖直扫描方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @lc code&#x3D;start</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if(strs &#x3D;&#x3D; null || strs.length &#x3D;&#x3D; 0) return &quot;&quot;;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; strs[0].length(); i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取第一个字符串每一个位置上的字符 c</span><br><span class="line">            char c &#x3D; strs[0].charAt(i);</span><br><span class="line">            &#x2F;&#x2F; j从1开始，拿第一个字符串和之后的字符串进行比较</span><br><span class="line">            for(int j &#x3D; 1; j &lt; strs.length; j++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断之后的每一个字符串(strs[j])的第i位置上的字符串是否等于第一个字符串每一个位置上的字符 c （判断之前，一定要判断是否i已经是当前这个字符串的长度）</span><br><span class="line">                if(i &#x3D;&#x3D; strs[j].length() || strs[j].charAt(i)!&#x3D; c) &#123;</span><br><span class="line">                    return strs[0].substring(0,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果顺利走完了第一字符串的每一个位置，那么最长前缀就是第一个字符串</span><br><span class="line">        return strs[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>解法2 利用数组排序(按照字典序)特性</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;      </span><br><span class="line">        StringBuilder result &#x3D; new StringBuilder();</span><br><span class="line">         </span><br><span class="line">        if (strs!&#x3D; null &amp;&amp; strs.length &gt; 0)&#123;</span><br><span class="line">         </span><br><span class="line">            &#x2F;&#x2F;按照英文字母顺序排序</span><br><span class="line">            Arrays.sort(strs);</span><br><span class="line">             </span><br><span class="line">            char [] a &#x3D; strs[0].toCharArray();</span><br><span class="line">            char [] b &#x3D; strs[strs.length-1].toCharArray();</span><br><span class="line">             </span><br><span class="line">            for (int i &#x3D; 0; i &lt; a.length; i ++)&#123;</span><br><span class="line">                if (b[i] &#x3D;&#x3D; a[i])&#123;</span><br><span class="line">                    result.append(b[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    return result.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>四、总结</strong></p><p>这种”找规律“的模拟题，和小学奥数题十分类似。要提高自己的做题水平，需要坚持两个方向：</p><ul><li><p>自己多在纸上画图找规律，这种题没有什么通用解法</p></li><li><p>多做题，尽量对每种“规律”都有所接触</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&quot;14&quot;&gt;
&lt;li&gt;最长公共前缀&lt;br&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果不存在公共前缀，返回空字符串 “”。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;f</summary>
      
    
    
    
    
    <category term="leetcode.String" scheme="http://example.com/tags/leetcode-String/"/>
    
  </entry>
  
</feed>
