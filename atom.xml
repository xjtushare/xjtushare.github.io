<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-29T02:45:00.060Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Pu Cao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>611 有效三角形的个数</title>
    <link href="http://example.com/2021/03/29/611-triangleNumber/"/>
    <id>http://example.com/2021/03/29/611-triangleNumber/</id>
    <published>2021-03-29T02:27:23.000Z</published>
    <updated>2021-03-29T02:45:00.060Z</updated>
    
    <content type="html"><![CDATA[<p>有效三角形的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Tags</span><br><span class="line">array</span><br><span class="line"></span><br><span class="line">Companies</span><br><span class="line">给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [2,2,3,4]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">有效的组合是: </span><br><span class="line">2,3,4 (使用第一个 2)</span><br><span class="line">2,3,4 (使用第二个 2)</span><br><span class="line">2,2,3</span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">数组长度不超过1000。</span><br><span class="line">数组里整数的范围为 [0, 1000]。</span><br></pre></td></tr></table></figure><p><strong>解法</strong><br>组成三角形条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任意的两边之和大于第三边</span><br></pre></td></tr></table></figure><p><strong>本题优化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">对 数组排序，比如[2,3,4,5,6]  </span><br><span class="line">一开始第三边为数组最后一个数 a&#x3D; nums.length-1;</span><br><span class="line">另外两个指针，left&#x3D;0；right&#x3D;nums.length-2;</span><br><span class="line">nums[left]&#x3D;2; nums[right]&#x3D;5,考察l到r的数是否满足两边之和大于第三边；</span><br><span class="line">如果2+5&gt;6,那么，从2开始到5之间的所有数加上5都是大于6的，也就是从下标0开始到下标2之间的数加上5都大于6，即</span><br><span class="line">2+5&gt;6</span><br><span class="line">3+5&gt;6</span><br><span class="line">4+5&gt;6</span><br><span class="line">所以，当l&#x3D;0，r&#x3D;nums.length-2时候，能够组成的三角形个数为count +&#x3D; r-l即3-0&#x3D;3，共有3个。</span><br><span class="line">然后当第三边为a&#x3D;nums.length-2的时候，继续考察... </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int triangleNumber(int[] nums) &#123;</span><br><span class="line">        if(nums.length&lt;3) return 0;</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        Arrays.sort(nums); &#x2F;&#x2F;like [2,3,4,5,6]</span><br><span class="line">        for(int a&#x3D;nums.length-1;a&gt;&#x3D;2;a-- )&#123;</span><br><span class="line">            int l&#x3D;0,r&#x3D;a-1;</span><br><span class="line">            while(l&lt;r)&#123;</span><br><span class="line">                if(nums[l]+nums[r]&gt;nums[a])&#123;</span><br><span class="line">                    &#x2F;&#x2F;nums[l]+nums[r]满足&gt;nums[a]，那么从l到r-1之间的所有元素加nums[r]都大于nums[a]</span><br><span class="line">                    count +&#x3D; r-l;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有效三角形的个数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://example.com/2021/03/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2021/03/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-03-27T07:00:23.000Z</published>
    <updated>2021-03-29T03:05:03.420Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>定义<br>进程是操作系统上的划分；<br>线程是在进程上的划分；<br>线程的执行速度要比进程快<br>Java是多线程编程语言，在进行并发访问处理的时候，可能获得很高的性能。</p></li><li><p>多线程实现</p></li></ol><p><strong>继承Thread类实现多线程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package basic_class_00.xiaodu.test;</span><br><span class="line"></span><br><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    private String title;</span><br><span class="line">    public MyThread(String title) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int x &#x3D; 0; x &lt; 6; x++) &#123;</span><br><span class="line">            System.out.println(this.title + &quot;运行.x &#x3D; &quot; + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new MyThread(&quot;线程A&quot;).run();</span><br><span class="line">        new MyThread(&quot;线程B&quot;).run();</span><br><span class="line">        new MyThread(&quot;线程C&quot;).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">线程A运行.x &#x3D; 0</span><br><span class="line">线程A运行.x &#x3D; 1</span><br><span class="line">线程A运行.x &#x3D; 2</span><br><span class="line">线程A运行.x &#x3D; 3</span><br><span class="line">线程A运行.x &#x3D; 4</span><br><span class="line">线程A运行.x &#x3D; 5</span><br><span class="line">线程B运行.x &#x3D; 0</span><br><span class="line">线程B运行.x &#x3D; 1</span><br><span class="line">线程B运行.x &#x3D; 2</span><br><span class="line">线程B运行.x &#x3D; 3</span><br><span class="line">线程B运行.x &#x3D; 4</span><br><span class="line">线程B运行.x &#x3D; 5</span><br><span class="line">线程C运行.x &#x3D; 0</span><br><span class="line">线程C运行.x &#x3D; 1</span><br><span class="line">线程C运行.x &#x3D; 2</span><br><span class="line">线程C运行.x &#x3D; 3</span><br><span class="line">线程C运行.x &#x3D; 4</span><br><span class="line">线程C运行.x &#x3D; 5</span><br></pre></td></tr></table></figure><p> <strong>start()方法启动多线程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    private String title;</span><br><span class="line">    public MyThread(String title) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int x &#x3D; 0; x &lt; 6; x++) &#123;</span><br><span class="line">            System.out.println(this.title + &quot;运行.x &#x3D; &quot; + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new MyThread(&quot;线程A&quot;).start();</span><br><span class="line">        new MyThread(&quot;线程B&quot;).start();</span><br><span class="line">        new MyThread(&quot;线程C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">线程A运行.x &#x3D; 0</span><br><span class="line">线程B运行.x &#x3D; 0</span><br><span class="line">线程B运行.x &#x3D; 1</span><br><span class="line">线程B运行.x &#x3D; 2</span><br><span class="line">线程B运行.x &#x3D; 3</span><br><span class="line">线程B运行.x &#x3D; 4</span><br><span class="line">线程B运行.x &#x3D; 5</span><br><span class="line">线程C运行.x &#x3D; 0</span><br><span class="line">线程C运行.x &#x3D; 1</span><br><span class="line">线程A运行.x &#x3D; 1</span><br><span class="line">线程C运行.x &#x3D; 2</span><br><span class="line">线程A运行.x &#x3D; 2</span><br><span class="line">线程A运行.x &#x3D; 3</span><br><span class="line">线程A运行.x &#x3D; 4</span><br><span class="line">线程A运行.x &#x3D; 5</span><br><span class="line">线程C运行.x &#x3D; 3</span><br><span class="line">线程C运行.x &#x3D; 4</span><br><span class="line">线程C运行.x &#x3D; 5</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义&lt;br&gt;进程是操作系统上的划分；&lt;br&gt;线程是在进程上的划分；&lt;br&gt;线程的执行速度要比进程快&lt;br&gt;Java是多线程编程语言，在进行并发访问处理的时候，可能获得很高的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多线程实现&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Array 数组</title>
    <link href="http://example.com/2021/03/25/array/"/>
    <id>http://example.com/2021/03/25/array/</id>
    <published>2021-03-25T06:02:25.000Z</published>
    <updated>2021-03-25T06:59:37.743Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1. 写法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int arr[10];</span><br></pre></td></tr></table></figure><p><strong>2. 特性</strong><br>内存中开辟连续地址，通过内存管理器直接访问，O(1)</p><p><strong>3. 缺点</strong><br><img src="/2021/03/25/array/16166524808045.jpg" alt="-w629"></p><p><strong>4. 源代码解析 –ArrayList</strong></p><ol><li>在数据的末尾添加一个元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * Appends the specified element to the end of this list.</span><br><span class="line">   *</span><br><span class="line">   * @param e element to be appended to this list</span><br><span class="line">   * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line">   *&#x2F;</span><br><span class="line">   &#x2F;&#x2F;1.把一个元素加入到数组最后</span><br><span class="line">  public boolean add(E e) &#123;</span><br><span class="line">  &#x2F;&#x2F;2.首先保证size有size+1这么大</span><br><span class="line">      ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">      &#x2F;&#x2F;3.然后在数据的末尾，添加上e这个元素，同时把size++，最后return true，表示添加成功</span><br><span class="line">      elementData[size++] &#x3D; e;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在index位置添加一个元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line">     * Inserts the specified element at the specified position in this</span><br><span class="line">     * list. Shifts the element currently at that position (if any) and</span><br><span class="line">     * any subsequent elements to the right (adds one to their indices).</span><br><span class="line">     *</span><br><span class="line">     * @param index index at which the specified element is to be inserted</span><br><span class="line">     * @param element element to be inserted</span><br><span class="line">     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void add(int index, E element) &#123;</span><br><span class="line">    &#x2F;&#x2F;1、检查上下界</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">&#x2F;&#x2F;2、确保容量</span><br><span class="line">        ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">       &#x2F;&#x2F;3. 拷贝： 把原来地址的起点位置，拷贝到目标地址的起点位置，source位置移动到index+1位置去</span><br><span class="line">       &#x2F;&#x2F;size-index即这个数组后半部分要挪到的部分， </span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                         size - index);</span><br><span class="line">        &#x2F;&#x2F;填入值</span><br><span class="line">        elementData[index] &#x3D; element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>即把EFG从3移动到了4的位置，如下图：</p><p><img src="/2021/03/25/array/16166535205113.jpg" alt="-w446"></p><p><strong>数组容量的保障策略</strong><br>如果数组的容量不够，直接new一个新的数组，新的数组的长度为当前数组的长度+当前数组长度的一半，即老数组的1.5倍。<br>然后把老数组的值拷贝到新数组中去，返回新的数组即可</p><p>因此如果对ArrayList进行大量修改操作，涉及到大量的array copy，所以时间复杂度是很低的。</p><p>为了弥补这个缺点，链表完美了解决了大量修改操作带来的时间复杂度开销问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">         grow(minCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F;新数组容量为老数组的1.5</span><br><span class="line"> int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line"> &#x2F;&#x2F;把所有元素拷贝到新数组中去</span><br><span class="line">elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">     </span><br></pre></td></tr></table></figure><p><strong>详细代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">    * Increases the capacity of this &lt;tt&gt;ArrayList&lt;&#x2F;tt&gt; instance, if</span><br><span class="line">    * necessary, to ensure that it can hold at least the number of elements</span><br><span class="line">    * specified by the minimum capacity argument.</span><br><span class="line">    *</span><br><span class="line">    * @param   minCapacity   the desired minimum capacity</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public void ensureCapacity(int minCapacity) &#123;</span><br><span class="line">       int minExpand &#x3D; (elementData !&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">           &#x2F;&#x2F; any size if not default element table</span><br><span class="line">           ? 0</span><br><span class="line">           &#x2F;&#x2F; larger than default for default empty table. It&#39;s already</span><br><span class="line">           &#x2F;&#x2F; supposed to be at default size.</span><br><span class="line">           : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">       if (minCapacity &gt; minExpand) &#123;</span><br><span class="line">           ensureExplicitCapacity(minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">       if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">       return minCapacity;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">       ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">       if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * Increases the capacity to ensure that it can hold at least the</span><br><span class="line">  * number of elements specified by the minimum capacity argument.</span><br><span class="line">  *</span><br><span class="line">  * @param minCapacity the desired minimum capacity</span><br><span class="line">  *&#x2F;</span><br><span class="line"> private void grow(int minCapacity) &#123;</span><br><span class="line">     &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">     int oldCapacity &#x3D; elementData.length;</span><br><span class="line">     &#x2F;&#x2F;新数组容量</span><br><span class="line">     int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">     if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">         newCapacity &#x3D; minCapacity;</span><br><span class="line">     if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">         newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">     &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:</span><br><span class="line">     &#x2F;&#x2F;把所有元素拷贝到新数组中去</span><br><span class="line">     elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;1. 写法&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;</summary>
      
    
    
    
    
    <category term="Data Structures" scheme="http://example.com/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>14 longest-common-prefix</title>
    <link href="http://example.com/2021/03/25/14_longest-common-prefix/"/>
    <id>http://example.com/2021/03/25/14_longest-common-prefix/</id>
    <published>2021-03-25T02:30:28.000Z</published>
    <updated>2021-03-25T04:55:39.857Z</updated>
    
    <content type="html"><![CDATA[<p>** Clarification(means Possible situation)：**<br>     *      1、 String arr null or empty?<br>     *      2、 String null or empty?<br>     *      3、 lower-case Englist letters? 如果有Upper-case，是否需要ignore case<br>     *<br>     * Solution 1:<br>     *  Horizontal Scan （水平比较）<br>     *      arr for loop 每两个字符串相比较，直到比较到最后一个字符串，就找到了共同前缀</p><p><img src="/2021/03/25/14_longest-common-prefix/16163813815934.jpg" alt="-w899"></p><p>不足：前面对owe的比较都是多余的，因为后面的单词中没有的，最终都被删除了。</p><p> <strong>Solution 1: vertically Scan (竖直扫描)</strong></p><p>   每个单词的第一个字符 f；<br>   每个单词的第二个字符 l；<br>   每个单词的第三个字符 0，i；<br>   =》共同前缀，fl</p><p>   <img src="/2021/03/25/14_longest-common-prefix/16163818004512.jpg" alt="-w887"></p><p><strong>key Points of Vertical Scan</strong></p><p><img src="/2021/03/25/14_longest-common-prefix/16163837594595.jpg" alt="-w881"></p><p>**1、拿到第一个字符串的第一个字符和后面的字符串比较<br>**    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c &#x3D; str[0].charAt(i);</span><br></pre></td></tr></table></figure><p><strong>2、Boundary check 数组越界检查</strong><br>如果i已经达到了当前这个string的长度，就说明可以停止继续scan了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(i&#x3D;&#x3D;str[j].length())&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>3.stop position is not part of the prefix</strong></p><p>**4、substring(start,end) **<br>是不包含end位置(end is excluded in the substring)，所以可以用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Strs[0].substring(0,i);</span><br></pre></td></tr></table></figure><p><strong>5、Finish Scan</strong><br>    已经走完的即 最长的共同前缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">return strs[0]</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line"></span><br><span class="line">**solution**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java&#x2F;Solution.java</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 示例 1：</span><br><span class="line"> *</span><br><span class="line"> * 输入：strs &#x3D; [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line"> * 输出：&quot;fl&quot;</span><br><span class="line"> *</span><br><span class="line"> * 示例 2：</span><br><span class="line"> * 输入：strs &#x3D; [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line"> * 输出：&quot;&quot;</span><br><span class="line"> * 解释：输入不存在公共前缀。</span><br><span class="line"></span><br><span class="line"> * 提示：</span><br><span class="line"> * strs[i] 仅由小写英文字母组成</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;start</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if(strs &#x3D;&#x3D; null || strs.length &#x3D;&#x3D; 0) return &quot;&quot;;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; strs[0].length(); i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取第一个字符串每一个位置上的字符 c</span><br><span class="line">            char c &#x3D; strs[0].charAt(i);</span><br><span class="line">            &#x2F;&#x2F; j从1开始，拿第一个字符串和之后的字符串进行比较</span><br><span class="line">            for(int j &#x3D; 1; j &lt; strs.length; j++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断之后的每一个字符串(strs[j])的第i位置上的字符串是否等于第一个字符串每一个位置上的字符 c （判断之前，一定要判断是否i已经是当前这个字符串的长度）</span><br><span class="line">                if(i &#x3D;&#x3D; strs[j].length() || strs[j].charAt(i)!&#x3D; c) &#123;</span><br><span class="line">                    return strs[0].substring(0,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果顺利走完了第一字符串的每一个位置，那么最长前缀就是第一个字符串</span><br><span class="line">        return strs[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;end</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;** Clarification(means Possible situation)：**&lt;br&gt;     *      1、 String arr null or empty?&lt;br&gt;     *      2、 String null or empty?&lt;br&gt;    </summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>200 numIslands</title>
    <link href="http://example.com/2021/03/24/200_numIslands/"/>
    <id>http://example.com/2021/03/24/200_numIslands/</id>
    <published>2021-03-24T10:30:28.000Z</published>
    <updated>2021-03-24T11:15:39.552Z</updated>
    
    <content type="html"><![CDATA[<p><strong>考点：深度搜索DFS</strong><br>  DFS：从一个点开始往下走，走到尽可能远，远到不能走下去的时候才返回上一级<br>一般用Recursion迭代，其中最关键的就是终止条件，</p><blockquote><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p></blockquote><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p> <strong>解析</strong>：<br><img src="/2021/03/24/200_numIslands/p1.png"></p><p><strong>point 1</strong><br>每次都是遇到‘1‘之后，开始DFS算法，也就是向四个方向延伸，直到不能继续延伸，就找到了一个岛</p><p><strong>point 2</strong><br>那么如何才能再二维数组中找到‘1’的点呢？  –》 two for loop<br>DFS，一般使用迭代，终止条件：<br>    1、走到不是1的时候停止<br>    2、走到了数组的边界就停止</p><p><strong>point 3</strong><br>  如何避免重复？<br>        1、避免重复遍历已经遍历过的元素，比如1；  –》标记法来避免（遍历过就把1标记为#）<br>        2、避免重复遍历已经遍历过的岛</p><p><img src="/2021/03/24/200_numIslands/p2.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;start</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int numIslands(char[][] arr) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; row</span><br><span class="line">        for(int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;    col</span><br><span class="line">            for(int j &#x3D; 0; j&lt; arr[0].length; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果当前元素arr[i][j]&#x3D;&#x3D;“1”，就进行DFS深搜</span><br><span class="line">                if(arr[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">                    dfs(arr, i, j);</span><br><span class="line">                    &#x2F;&#x2F;dfs深搜完之后，就说明产生了一个岛，res++，记录岛的num</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 深搜DFS</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void dfs(char[][] arr, int i, int j) &#123;</span><br><span class="line">        &#x2F;&#x2F;corner case  | arr[i][j] !&#x3D;&#39;1&#39; </span><br><span class="line">        if(i &lt; 0 || i &gt;&#x3D; arr.length || j &lt; 0 || j &gt;&#x3D; arr[0].length || arr[i][j] !&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 当前点标记为#</span><br><span class="line">        arr[i][j] &#x3D; &#39;#&#39;;</span><br><span class="line">        &#x2F;&#x2F;上下左右进行DFS</span><br><span class="line">        dfs(arr, i+1, j);</span><br><span class="line">        dfs(arr, i-1, j);</span><br><span class="line">        dfs(arr, i, j+1);</span><br><span class="line">        dfs(arr, i, j-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;end</span><br><span class="line"></span><br><span class="line">****</span><br></pre></td></tr></table></figure><p><img src="/2021/03/24/200_numIslands/p3.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;考点：深度搜索DFS&lt;/strong&gt;&lt;br&gt;  DFS：从一个点开始往下走，走到尽可能远，远到不能走下去的时候才返回上一级&lt;br&gt;一般用Recursion迭代，其中最关键的就是终止条件，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个由 ‘1’（陆地）和</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
