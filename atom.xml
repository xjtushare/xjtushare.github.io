<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>返璞归真</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-30T02:16:26.602Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Pu Cao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>20. 有效的括号</title>
    <link href="http://example.com/2021/03/30/20-Valid-Parentheses/"/>
    <id>http://example.com/2021/03/30/20-Valid-Parentheses/</id>
    <published>2021-03-30T02:07:20.000Z</published>
    <updated>2021-03-30T02:16:26.602Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。</span><br><span class="line"></span><br><span class="line">有效字符串需满足：</span><br><span class="line"></span><br><span class="line">左括号必须用相同类型的右括号闭合。</span><br><span class="line">左括号必须以正确的顺序闭合。</span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;()&quot;</span><br><span class="line">输出：true</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;(]&quot;</span><br><span class="line">输出：false</span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;([)]&quot;</span><br><span class="line">输出：false</span><br><span class="line">示例 5：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出：true</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; s.length &lt;&#x3D; 104</span><br><span class="line">s 仅由括号 &#39;()[]&#123;&#125;&#39; 组成</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>栈解决的问题：</li><li>最近相关性</li><li>先来后到，先进后出问题。</li><li>比较复杂的算法最后都归结到找最近的重复性</li><li>因为只能写 if else; for loop 和recursion</li></ul><p>  <strong>解法：</strong><br> <strong>1.暴力</strong><br> ：不断replace匹配的括号</p><ul><li>情况： a. ()[]{}</li><li>b. (([]))  找到匹配的替换成空</li><li>o(n平方)</li></ul><p> <strong>2.使用栈</strong></p><ul><li><p>如果是左括号，就压入右括号到栈里面去；</p></li><li><p>loop</p></li><li><p>如果是右括号，就和栈顶元素进行匹配，如果匹配，就把栈顶元素移除栈，消除这对括号</p></li><li><p>不然就不合法。</p></li><li><p>if 左括号，入栈</p></li><li><p>else if 右括号，则和栈顶元素进行比较，看是否匹配</p></li><li><p>if 匹配，栈顶元素出栈，栈中元素减少一个，同时字符串的index跳到下一个字符</p></li><li><p>最后要判断下栈里面的所有元素都清空了，且每一次扫描的字符不会和栈顶元素匹配不上</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class isValid &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F;        遍历一遍整个字符串，遇到左括号，把相对应的右括号压入栈，</span><br><span class="line">&#x2F;&#x2F;        这样弹栈pop的时候，弹出的值和当前字符串中扫描到的值是否一样</span><br><span class="line">        for (char c : s.toCharArray()) &#123;</span><br><span class="line">            if (c &#x3D;&#x3D; &#39;(&#39;) &#123;</span><br><span class="line">                stack.push(&#39;)&#39;);</span><br><span class="line">            &#125; else if (c &#x3D;&#x3D; &#39;&#123;&#39;) &#123;</span><br><span class="line">                stack.push(&#39;&#125;&#39;);</span><br><span class="line">            &#125; else if (c &#x3D;&#x3D; &#39;[&#39;) &#123;</span><br><span class="line">                stack.push(&#39;]&#39;);</span><br><span class="line">            &#125; else if (stack.isEmpty() || stack.pop() !&#x3D; c) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>200 numIslands</title>
    <link href="http://example.com/2021/03/30/200-numIslands/"/>
    <id>http://example.com/2021/03/30/200-numIslands/</id>
    <published>2021-03-30T01:57:44.000Z</published>
    <updated>2021-03-30T02:56:00.813Z</updated>
    
    <content type="html"><![CDATA[<p><strong>考点：深度搜索DFS</strong><br>DFS：从一个点开始往下走，走到尽可能远，远到不能走下去的时候才返回上一级<br>一般用Recursion迭代，其中最关键的就是终止条件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</span><br><span class="line">岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</span><br><span class="line">此外，你可以假设该网格的四条边均被水包围。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>解析：</strong><br><img src="/2021/03/30/200-numIslands/p1.png" alt="-"></p><p><strong>point 1</strong><br>每次都是遇到‘1‘之后，开始DFS算法，也就是向四个方向延伸，直到不能继续延伸，就找到了一个岛</p><p><strong>point 2</strong><br>那么如何才能再二维数组中找到‘1’的点呢？ –》 two for loop<br>DFS，一般使用迭代，终止条件：<br>1、走到不是1的时候停止<br>2、走到了数组的边界就停止</p><p><strong>point 3</strong><br>如何避免重复？<br>1、避免重复遍历已经遍历过的元素，比如1； –》标记法来避免（遍历过就把1标记为#）<br>2、避免重复遍历已经遍历过的岛</p><p> <img src="/2021/03/30/200-numIslands/p2.png" alt="-"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @lc code&#x3D;start</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int numIslands(char[][] arr) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; row</span><br><span class="line">        for(int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;    col</span><br><span class="line">            for(int j &#x3D; 0; j&lt; arr[0].length; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果当前元素arr[i][j]&#x3D;&#x3D;“1”，就进行DFS深搜</span><br><span class="line">                if(arr[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">                    dfs(arr, i, j);</span><br><span class="line">                    &#x2F;&#x2F;dfs深搜完之后，就说明产生了一个岛，res++，记录岛的num</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 深搜DFS</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void dfs(char[][] arr, int i, int j) &#123;</span><br><span class="line">        &#x2F;&#x2F;corner case  | arr[i][j] !&#x3D;&#39;1&#39; </span><br><span class="line">        if(i &lt; 0 || i &gt;&#x3D; arr.length || j &lt; 0 || j &gt;&#x3D; arr[0].length || arr[i][j] !&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 当前点标记为#</span><br><span class="line">        arr[i][j] &#x3D; &#39;#&#39;;</span><br><span class="line">        &#x2F;&#x2F;上下左右进行DFS</span><br><span class="line">        dfs(arr, i+1, j);</span><br><span class="line">        dfs(arr, i-1, j);</span><br><span class="line">        dfs(arr, i, j+1);</span><br><span class="line">        dfs(arr, i, j-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;end</span><br><span class="line"></span><br><span class="line">****</span><br></pre></td></tr></table></figure><p><img src="/2021/03/30/200-numIslands/p3.png" alt="-"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;考点：深度搜索DFS&lt;/strong&gt;&lt;br&gt;DFS：从一个点开始往下走，走到尽可能远，远到不能走下去的时候才返回上一级&lt;br&gt;一般用Recursion迭代，其中最关键的就是终止条件，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>98. 验证二叉搜索树</title>
    <link href="http://example.com/2021/03/29/98-ValidateBinarySearchTree/"/>
    <id>http://example.com/2021/03/29/98-ValidateBinarySearchTree/</id>
    <published>2021-03-29T08:29:16.000Z</published>
    <updated>2021-03-29T08:39:25.792Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，判断其是否是一个有效的二叉搜索树。</span><br><span class="line"></span><br><span class="line">假设一个二叉搜索树具有如下特征：</span><br><span class="line"></span><br><span class="line">节点的左子树只包含小于当前节点的数。</span><br><span class="line">节点的右子树只包含大于当前节点的数。</span><br><span class="line">所有左子树和右子树自身必须也是二叉搜索树。</span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;validate-binary-search-tree</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p><strong>解法</strong></p><ol><li><p>方法2:inorder, =&gt; array 升序，不需要保留所有节点，只需要保留前继节点即可</p></li><li><p>递归： Recursion  </p><pre><code>  valid(root,min,max)&#123;&#125;  max &lt;-  valid(node.left)  min &lt;- valid(node.right)  左边 max&lt;root, 并且 右边min &gt;root 说明是二叉搜素树  同理，递归</code></pre></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">解法: 定义一个全局最大值，最小值，</span><br><span class="line">如果根节点的值大于全局最大值，或者小于全局最小值，则不满足二叉搜索树的性质。</span><br><span class="line">然后对左子树和右子树进行考察，</span><br><span class="line">如果是二叉搜素树，那么左子树的最大值必须小于根节点，即根节点为左子树的上界；</span><br><span class="line">并且右子树的最小值必须大于根节点的值，所以更新右子树的最小值为root.val</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val &#x3D; val;</span><br><span class="line"> *         this.left &#x3D; left;</span><br><span class="line"> *         this.right &#x3D; right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        &#x2F;&#x2F;定义全局的最大值，最小值</span><br><span class="line">        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isValidBST(TreeNode root, long minVal, long maxVal) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) return true;</span><br><span class="line">        &#x2F;&#x2F;所有的节点的上下界，max，min</span><br><span class="line">        if (root.val &gt;&#x3D; maxVal || root.val &lt;&#x3D; minVal) return false;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 遍历左子树</span><br><span class="line">         * 左子树不能大于root，所以root.val变成了上界</span><br><span class="line">         * 同理：遍历右子树</span><br><span class="line">         * 右子树所有节点都比root.val大，所以右子树变为了下界</span><br><span class="line">         *&#x2F;</span><br><span class="line">        return isValidBST(root.left, minVal, root.val) &amp;&amp; isValidBST(root.right, root.val, maxVal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>611 有效三角形的个数</title>
    <link href="http://example.com/2021/03/29/611-triangleNumber/"/>
    <id>http://example.com/2021/03/29/611-triangleNumber/</id>
    <published>2021-03-29T02:27:23.000Z</published>
    <updated>2021-03-29T02:45:00.060Z</updated>
    
    <content type="html"><![CDATA[<p>有效三角形的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Tags</span><br><span class="line">array</span><br><span class="line"></span><br><span class="line">Companies</span><br><span class="line">给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [2,2,3,4]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">有效的组合是: </span><br><span class="line">2,3,4 (使用第一个 2)</span><br><span class="line">2,3,4 (使用第二个 2)</span><br><span class="line">2,2,3</span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">数组长度不超过1000。</span><br><span class="line">数组里整数的范围为 [0, 1000]。</span><br></pre></td></tr></table></figure><p><strong>解法</strong><br>组成三角形条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任意的两边之和大于第三边</span><br></pre></td></tr></table></figure><p><strong>本题优化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">对 数组排序，比如[2,3,4,5,6]  </span><br><span class="line">一开始第三边为数组最后一个数 a&#x3D; nums.length-1;</span><br><span class="line">另外两个指针，left&#x3D;0；right&#x3D;nums.length-2;</span><br><span class="line">nums[left]&#x3D;2; nums[right]&#x3D;5,考察l到r的数是否满足两边之和大于第三边；</span><br><span class="line">如果2+5&gt;6,那么，从2开始到5之间的所有数加上5都是大于6的，也就是从下标0开始到下标2之间的数加上5都大于6，即</span><br><span class="line">2+5&gt;6</span><br><span class="line">3+5&gt;6</span><br><span class="line">4+5&gt;6</span><br><span class="line">所以，当l&#x3D;0，r&#x3D;nums.length-2时候，能够组成的三角形个数为count +&#x3D; r-l即3-0&#x3D;3，共有3个。</span><br><span class="line">然后当第三边为a&#x3D;nums.length-2的时候，继续考察... </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int triangleNumber(int[] nums) &#123;</span><br><span class="line">        if(nums.length&lt;3) return 0;</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        Arrays.sort(nums); &#x2F;&#x2F;like [2,3,4,5,6]</span><br><span class="line">        for(int a&#x3D;nums.length-1;a&gt;&#x3D;2;a-- )&#123;</span><br><span class="line">            int l&#x3D;0,r&#x3D;a-1;</span><br><span class="line">            while(l&lt;r)&#123;</span><br><span class="line">                if(nums[l]+nums[r]&gt;nums[a])&#123;</span><br><span class="line">                    &#x2F;&#x2F;nums[l]+nums[r]满足&gt;nums[a]，那么从l到r-1之间的所有元素加nums[r]都大于nums[a]</span><br><span class="line">                    count +&#x3D; r-l;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有效三角形的个数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://example.com/2021/03/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2021/03/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-03-27T07:00:23.000Z</published>
    <updated>2021-03-29T03:21:32.742Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>定义<br>进程是操作系统上的划分；<br>线程是在进程上的划分；<br>线程的执行速度要比进程快<br>Java是多线程编程语言，在进行并发访问处理的时候，可能获得很高的性能。</p></li><li><p>多线程实现</p></li></ol><p><strong>继承Thread类实现多线程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package basic_class_00.xiaodu.test;</span><br><span class="line"></span><br><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    private String title;</span><br><span class="line">    public MyThread(String title) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int x &#x3D; 0; x &lt; 6; x++) &#123;</span><br><span class="line">            System.out.println(this.title + &quot;运行.x &#x3D; &quot; + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new MyThread(&quot;线程A&quot;).run();</span><br><span class="line">        new MyThread(&quot;线程B&quot;).run();</span><br><span class="line">        new MyThread(&quot;线程C&quot;).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">线程A运行.x &#x3D; 0</span><br><span class="line">线程A运行.x &#x3D; 1</span><br><span class="line">线程A运行.x &#x3D; 2</span><br><span class="line">线程A运行.x &#x3D; 3</span><br><span class="line">线程A运行.x &#x3D; 4</span><br><span class="line">线程A运行.x &#x3D; 5</span><br><span class="line">线程B运行.x &#x3D; 0</span><br><span class="line">线程B运行.x &#x3D; 1</span><br><span class="line">线程B运行.x &#x3D; 2</span><br><span class="line">线程B运行.x &#x3D; 3</span><br><span class="line">线程B运行.x &#x3D; 4</span><br><span class="line">线程B运行.x &#x3D; 5</span><br><span class="line">线程C运行.x &#x3D; 0</span><br><span class="line">线程C运行.x &#x3D; 1</span><br><span class="line">线程C运行.x &#x3D; 2</span><br><span class="line">线程C运行.x &#x3D; 3</span><br><span class="line">线程C运行.x &#x3D; 4</span><br><span class="line">线程C运行.x &#x3D; 5</span><br></pre></td></tr></table></figure><p> <strong>start()方法启动多线程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    private String title;</span><br><span class="line">    public MyThread(String title) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int x &#x3D; 0; x &lt; 6; x++) &#123;</span><br><span class="line">            System.out.println(this.title + &quot;运行.x &#x3D; &quot; + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new MyThread(&quot;线程A&quot;).start();</span><br><span class="line">        new MyThread(&quot;线程B&quot;).start();</span><br><span class="line">        new MyThread(&quot;线程C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">线程A运行.x &#x3D; 0</span><br><span class="line">线程B运行.x &#x3D; 0</span><br><span class="line">线程B运行.x &#x3D; 1</span><br><span class="line">线程B运行.x &#x3D; 2</span><br><span class="line">线程B运行.x &#x3D; 3</span><br><span class="line">线程B运行.x &#x3D; 4</span><br><span class="line">线程B运行.x &#x3D; 5</span><br><span class="line">线程C运行.x &#x3D; 0</span><br><span class="line">线程C运行.x &#x3D; 1</span><br><span class="line">线程A运行.x &#x3D; 1</span><br><span class="line">线程C运行.x &#x3D; 2</span><br><span class="line">线程A运行.x &#x3D; 2</span><br><span class="line">线程A运行.x &#x3D; 3</span><br><span class="line">线程A运行.x &#x3D; 4</span><br><span class="line">线程A运行.x &#x3D; 5</span><br><span class="line">线程C运行.x &#x3D; 3</span><br><span class="line">线程C运行.x &#x3D; 4</span><br><span class="line">线程C运行.x &#x3D; 5</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义&lt;br&gt;进程是操作系统上的划分；&lt;br&gt;线程是在进程上的划分；&lt;br&gt;线程的执行速度要比进程快&lt;br&gt;Java是多线程编程语言，在进行并发访问处理的时候，可能获得很高的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多线程实现&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
      
    
    
    
    
    <category term="Programming Language" scheme="http://example.com/tags/Programming-Language/"/>
    
  </entry>
  
  <entry>
    <title>Array 数组</title>
    <link href="http://example.com/2021/03/25/array/"/>
    <id>http://example.com/2021/03/25/array/</id>
    <published>2021-03-25T06:02:25.000Z</published>
    <updated>2021-03-25T06:59:37.743Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1. 写法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int arr[10];</span><br></pre></td></tr></table></figure><p><strong>2. 特性</strong><br>内存中开辟连续地址，通过内存管理器直接访问，O(1)</p><p><strong>3. 缺点</strong><br><img src="/2021/03/25/array/16166524808045.jpg" alt="-w629"></p><p><strong>4. 源代码解析 –ArrayList</strong></p><ol><li>在数据的末尾添加一个元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * Appends the specified element to the end of this list.</span><br><span class="line">   *</span><br><span class="line">   * @param e element to be appended to this list</span><br><span class="line">   * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line">   *&#x2F;</span><br><span class="line">   &#x2F;&#x2F;1.把一个元素加入到数组最后</span><br><span class="line">  public boolean add(E e) &#123;</span><br><span class="line">  &#x2F;&#x2F;2.首先保证size有size+1这么大</span><br><span class="line">      ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">      &#x2F;&#x2F;3.然后在数据的末尾，添加上e这个元素，同时把size++，最后return true，表示添加成功</span><br><span class="line">      elementData[size++] &#x3D; e;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在index位置添加一个元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line">     * Inserts the specified element at the specified position in this</span><br><span class="line">     * list. Shifts the element currently at that position (if any) and</span><br><span class="line">     * any subsequent elements to the right (adds one to their indices).</span><br><span class="line">     *</span><br><span class="line">     * @param index index at which the specified element is to be inserted</span><br><span class="line">     * @param element element to be inserted</span><br><span class="line">     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void add(int index, E element) &#123;</span><br><span class="line">    &#x2F;&#x2F;1、检查上下界</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">&#x2F;&#x2F;2、确保容量</span><br><span class="line">        ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">       &#x2F;&#x2F;3. 拷贝： 把原来地址的起点位置，拷贝到目标地址的起点位置，source位置移动到index+1位置去</span><br><span class="line">       &#x2F;&#x2F;size-index即这个数组后半部分要挪到的部分， </span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                         size - index);</span><br><span class="line">        &#x2F;&#x2F;填入值</span><br><span class="line">        elementData[index] &#x3D; element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>即把EFG从3移动到了4的位置，如下图：</p><p><img src="/2021/03/25/array/16166535205113.jpg" alt="-w446"></p><p><strong>数组容量的保障策略</strong><br>如果数组的容量不够，直接new一个新的数组，新的数组的长度为当前数组的长度+当前数组长度的一半，即老数组的1.5倍。<br>然后把老数组的值拷贝到新数组中去，返回新的数组即可</p><p>因此如果对ArrayList进行大量修改操作，涉及到大量的array copy，所以时间复杂度是很低的。</p><p>为了弥补这个缺点，链表完美了解决了大量修改操作带来的时间复杂度开销问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">         grow(minCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F;新数组容量为老数组的1.5</span><br><span class="line"> int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line"> &#x2F;&#x2F;把所有元素拷贝到新数组中去</span><br><span class="line">elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">     </span><br></pre></td></tr></table></figure><p><strong>详细代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">    * Increases the capacity of this &lt;tt&gt;ArrayList&lt;&#x2F;tt&gt; instance, if</span><br><span class="line">    * necessary, to ensure that it can hold at least the number of elements</span><br><span class="line">    * specified by the minimum capacity argument.</span><br><span class="line">    *</span><br><span class="line">    * @param   minCapacity   the desired minimum capacity</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public void ensureCapacity(int minCapacity) &#123;</span><br><span class="line">       int minExpand &#x3D; (elementData !&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">           &#x2F;&#x2F; any size if not default element table</span><br><span class="line">           ? 0</span><br><span class="line">           &#x2F;&#x2F; larger than default for default empty table. It&#39;s already</span><br><span class="line">           &#x2F;&#x2F; supposed to be at default size.</span><br><span class="line">           : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">       if (minCapacity &gt; minExpand) &#123;</span><br><span class="line">           ensureExplicitCapacity(minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">       if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">       return minCapacity;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">       ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">       if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * Increases the capacity to ensure that it can hold at least the</span><br><span class="line">  * number of elements specified by the minimum capacity argument.</span><br><span class="line">  *</span><br><span class="line">  * @param minCapacity the desired minimum capacity</span><br><span class="line">  *&#x2F;</span><br><span class="line"> private void grow(int minCapacity) &#123;</span><br><span class="line">     &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">     int oldCapacity &#x3D; elementData.length;</span><br><span class="line">     &#x2F;&#x2F;新数组容量</span><br><span class="line">     int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">     if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">         newCapacity &#x3D; minCapacity;</span><br><span class="line">     if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">         newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">     &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:</span><br><span class="line">     &#x2F;&#x2F;把所有元素拷贝到新数组中去</span><br><span class="line">     elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;1. 写法&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;</summary>
      
    
    
    
    
    <category term="Data Structures" scheme="http://example.com/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>14 longest-common-prefix</title>
    <link href="http://example.com/2021/03/25/14_longest-common-prefix/"/>
    <id>http://example.com/2021/03/25/14_longest-common-prefix/</id>
    <published>2021-03-25T02:30:28.000Z</published>
    <updated>2021-03-30T06:54:04.705Z</updated>
    
    <content type="html"><![CDATA[<p>#一、题目描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">14. 最长公共前缀</span><br><span class="line">编写一个函数来查找字符串数组中的最长公共前缀。</span><br><span class="line"></span><br><span class="line">如果不存在公共前缀，返回空字符串 &quot;&quot;。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：strs &#x3D; [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出：&quot;fl&quot;</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：strs &#x3D; [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：输入不存在公共前缀。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">0 &lt;&#x3D; strs.length &lt;&#x3D; 200</span><br><span class="line">0 &lt;&#x3D; strs[i].length &lt;&#x3D; 200</span><br><span class="line">strs[i] 仅由小写英文字母组成</span><br></pre></td></tr></table></figure><p>#二、思路分析：<br>** Clarification(means Possible situation)：**<br>     *      1、 String arr null or empty?<br>     *      2、 String null or empty?<br>     *      3、 lower-case Englist letters? 如果有Upper-case，是否需要ignore case<br>     *<br>     * Solution 1:<br>     *  Horizontal Scan （水平比较）<br>     *      arr for loop 每两个字符串相比较，直到比较到最后一个字符串，就找到了共同前缀</p><p><img src="/2021/03/25/14_longest-common-prefix/16163813815934.jpg" alt="-w899"></p><p>不足：前面对owe的比较都是多余的，因为后面的单词中没有的，最终都被删除了。</p><p> <strong>Solution 1: vertically Scan (竖直扫描)</strong></p><p>   每个单词的第一个字符 f；<br>   每个单词的第二个字符 l；<br>   每个单词的第三个字符 0，i；<br>   =》共同前缀，fl</p><p>   <img src="/2021/03/25/14_longest-common-prefix/16163818004512.jpg" alt="-w887"></p><p><strong>key Points of Vertical Scan</strong></p><p><img src="/2021/03/25/14_longest-common-prefix/16163837594595.jpg" alt="-w881"></p><p>**1、拿到第一个字符串的第一个字符和后面的字符串比较<br>**    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c &#x3D; str[0].charAt(i);</span><br></pre></td></tr></table></figure><p><strong>2、Boundary check 数组越界检查</strong><br>如果i已经达到了当前这个string的长度，就说明可以停止继续scan了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(i&#x3D;&#x3D;str[j].length())&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>3.stop position is not part of the prefix</strong></p><p>**4、substring(start,end) **<br>是不包含end位置(end is excluded in the substring)，所以可以用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Strs[0].substring(0,i);</span><br></pre></td></tr></table></figure><p><strong>5、Finish Scan</strong><br>    已经走完的即 最长的共同前缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">return strs[0]</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line"></span><br><span class="line">**solution**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#三、AC代码：</span><br><span class="line">&#96;&#96;&#96;java&#x2F;Solution.java</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 示例 1：</span><br><span class="line"> *</span><br><span class="line"> * 输入：strs &#x3D; [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line"> * 输出：&quot;fl&quot;</span><br><span class="line"> *</span><br><span class="line"> * 示例 2：</span><br><span class="line"> * 输入：strs &#x3D; [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line"> * 输出：&quot;&quot;</span><br><span class="line"> * 解释：输入不存在公共前缀。</span><br><span class="line"></span><br><span class="line"> * 提示：</span><br><span class="line"> * strs[i] 仅由小写英文字母组成</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;start</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if(strs &#x3D;&#x3D; null || strs.length &#x3D;&#x3D; 0) return &quot;&quot;;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; strs[0].length(); i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取第一个字符串每一个位置上的字符 c</span><br><span class="line">            char c &#x3D; strs[0].charAt(i);</span><br><span class="line">            &#x2F;&#x2F; j从1开始，拿第一个字符串和之后的字符串进行比较</span><br><span class="line">            for(int j &#x3D; 1; j &lt; strs.length; j++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断之后的每一个字符串(strs[j])的第i位置上的字符串是否等于第一个字符串每一个位置上的字符 c （判断之前，一定要判断是否i已经是当前这个字符串的长度）</span><br><span class="line">                if(i &#x3D;&#x3D; strs[j].length() || strs[j].charAt(i)!&#x3D; c) &#123;</span><br><span class="line">                    return strs[0].substring(0,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果顺利走完了第一字符串的每一个位置，那么最长前缀就是第一个字符串</span><br><span class="line">        return strs[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; @lc code&#x3D;end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>解法二 利用数组排序特性</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;      </span><br><span class="line">        StringBuilder result &#x3D; new StringBuilder();</span><br><span class="line">         </span><br><span class="line">        if (strs!&#x3D; null &amp;&amp; strs.length &gt; 0)&#123;</span><br><span class="line">         </span><br><span class="line">            &#x2F;&#x2F;按照英文字母顺序排序</span><br><span class="line">            Arrays.sort(strs);</span><br><span class="line">             </span><br><span class="line">            char [] a &#x3D; strs[0].toCharArray();</span><br><span class="line">            char [] b &#x3D; strs[strs.length-1].toCharArray();</span><br><span class="line">             </span><br><span class="line">            for (int i &#x3D; 0; i &lt; a.length; i ++)&#123;</span><br><span class="line">                if (b[i] &#x3D;&#x3D; a[i])&#123;</span><br><span class="line">                    result.append(b[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    return result.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#四、总结</p><p>这种”找规律“的模拟题，和小学奥数题十分类似。要提高自己的做题水平，需要坚持两个方向：</p><ul><li><p>自己多在纸上画图找规律，这种题没有什么通用解法</p></li><li><p>多做题，尽量对每种“规律”都有所接触</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#一、题目描述：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
